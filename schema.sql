/** 
* AUTHORS
* Description: Author of the door content.
*/
create table authors (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text,
  twitter_handle text,
  website_url text
);
alter table authors enable row level security;
CREATE POLICY "Enable public read access" ON public.authors FOR SELECT USING (true);

/** 
* DOORS
* Description: These are the doors of the advent calendar.
*/
create table doors (
  id bigint generated by default as identity primary key,
  author_id bigint references authors 
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  title text,
  desscription text,
  image_url text,
  author_url text,
  opening_date date,
  likes bigint
);
alter table doors enable row level security;
CREATE POLICY "Only return open doors" ON public.doors FOR SELECT USING (now() >= opening_date);
CREATE POLICY "Enable insert for admins" ON public.doors FOR INSERT WITH CHECK (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = uid()) AND (profiles.role = 'admin'::text))))


/** 
* PROFILES
* Description: Extra app specific user data.
*/
create table profiles (
  -- UUID from auth.users
  id uuid references auth.users not null primary key,
  email text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  role text
);
alter table profiles enable row level security;
create policy "Can view own user data." on profiles for select using (auth.uid() = id);
create policy "Can update own user data." on profiles for update using (auth.uid() = id);

/**
* This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
*/ 
create function public.create_profile_for_user() 
returns trigger as $$
begin
  insert into public.profiles(id, email)
  values(new.id, new.email);

  return new;
end;
$$ language plpgsql security definer;
create trigger create_profile_trigger
  after insert on auth.users
  for each row execute procedure public.create_profile_for_user();

/** 
* Sync the auth.user app_metadata with the role in our profiles table
*/
create function public.update_app_metadata() 
returns trigger as $$
begin
  update auth.users
  set raw_app_meta_data = jsonb_set("raw_app_meta_data"::jsonb, '{role}', to_jsonb(new.role::text)) where id = new.id;

  return new;
end;
$$ language plpgsql security definer;
create trigger update_app_metadata_with_profile
  after update on public.profiles
  for each row execute procedure public.update_app_metadata();


/**
* INCREMENT HELPER FUNCTION
*/
create function public.increment_likes (door_id int) 
returns void as
$$
  update public.doors 
  set likes = likes + 1
  where id = door_id
$$ 
language sql volatile;